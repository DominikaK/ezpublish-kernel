# Abstract FieldTypes features

Most FieldTypes implement the FieldType API directly. There is one exception, though: BinaryBase, used by
`BinaryFile` and `Media` (but not `Image`). Abstract FieldTypes are another application of this approach,
but this time aiming at simplifying FieldType for 3rd party implementors. This would be achieved by
providing re-usable abstract elements that can be used as the basis for the various parts of a FieldType:
Type, Value, Converter, External storage, templates, ...

## Legacy Converters

### How legacy converters work
A `LegacyConverter` maps a FieldType's data to the legacy storage engine structure.

It serializes a Type's `FieldValue` and `FieldDefinition` objects to the `ezcontentobject_attribute`
and `ezcontentclass_attribute` tables. This includes:
- value data, by means of the `ezcontentclass_attribute.data_*` fields: `data_text`, `data_int`, `data_float`
- value sort field, by means of the `ezcontentclass_attribute.sort_key_*` fields: `sort_key_string` and `sort_key_int`
- field definition data, by means of the `data_*_N` fields: `data_text_[1-5]`, `data_float_[1-4]` and `data_int_[1-4]`

#### `JsonLegacyConverter`
Serializes a FieldValue to a JSON structure, with the properties names as the keys.

- Applicable `FieldValue::data` types: `array`.
- Auto-wireable: `yes` (by reading the Type's `toHash` return type)

Example:

```php
class MyJsonConverter extends JsonLegacyConverter
{
    /**
     * Parent implementation.
     */
    public function toStorageValue(FieldValue $value, StorageFieldValue $storageFieldValue)
    {
        $storageFieldValue->dataText = json_encode($value->data);
    }
    
    /**
     *
     */
    public function toFieldValue(StorageFieldValue $storageFieldValue, FieldValue $value)
    {
        $fieldValue->data = json_decode($storageFieldValue->dataText);
    }
}
```

Open questions:
- Should it abstract serialization so that custom serializers can be configured ? Probably.
- Should we prefer a service over a parent class ? The 3rd party Converter could be injected
  a FieldValueSerializer. An Abstract JsonSerializer could then be added on top of that, keeping
  the Serializer usable independently.

#### `ConfigurablePropertyAccessLegacyConverter`
Serializes a `FieldValue` my mapping the data to the `StorageFieldValue` properties.
The Converter is configured using the service definition. The service definition may be automatically
generated by the compiler based on the implementation.
 
Example with TextLine:
```yaml
services:
    textline_type_converter:
        class: ConfigurableMapLegacyConverter
        arguments:
            -
                # Key is the legacy storage engine field
                # Value is a PropertyAccess on the FieldValue object 
                value:
                    data_text: value
                # Key is the legacy storage engine field
                # Value is a PropertyAccess on the FieldDefinition object 
                Uses PropertyAccess on the FieldDefinition object
                definition: 
                    data_text_1: defaultValue
                    data_int_1: fieldTypeConstraints.validators[StringLengthValidator][minStringLength]
                    data_int_2: fieldTypeConstraints.validators[StringLengthValidator][maxStringLength]
        tags:
            - {name: ezpublish.storageEngine.legacy.converter, alias: my_fieldtype}
```

Open questions:
- Would this work better with semantic configuration ?
- As above, this probably works better with a serializer

## Open questions

### `SerializerConverter` ?

This kind of leans towards an abstract `SerializerConverter`.
A Type is given its own serizalizer, by means of DI  / configuration / auto-wiring... 
